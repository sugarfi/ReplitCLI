"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var protocol_1 = require("@replit/protocol");
var channel_1 = require("./channel");
var deferred_1 = require("./deferred");
var EIOCompat_1 = require("./EIOCompat");
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["CONNECTING"] = 0] = "CONNECTING";
    ConnectionState[ConnectionState["CONNECTED"] = 1] = "CONNECTED";
    ConnectionState[ConnectionState["DISCONNECTED"] = 2] = "DISCONNECTED";
})(ConnectionState || (ConnectionState = {}));
var isWebSocket = function (w) {
    if (typeof w !== 'object' && typeof w !== 'function') {
        return false;
    }
    if (!w) {
        return false;
    }
    return 'OPEN' in w && w.OPEN === 1;
};
var getWebSocketClass = function (options) {
    if (options.WebSocketClass) {
        if (!isWebSocket(options.WebSocketClass)) {
            throw new Error('Passed in WebSocket does not look like a standard WebSocket');
        }
        return options.WebSocketClass;
    }
    if (typeof WebSocket !== 'undefined') {
        if (!isWebSocket(WebSocket)) {
            throw new Error('Global WebSocket does not look like a standard WebSocket');
        }
        return WebSocket;
    }
    throw new Error('Please pass in a WebSocket class, add it to global, or use the polling option');
};
var Client = (function (_super) {
    __extends(Client, _super);
    function Client(debug) {
        if (debug === void 0) { debug = function () { }; }
        var _this = _super.call(this) || this;
        _this.isConnected = function () { return _this.connectionState === ConnectionState.CONNECTED; };
        _this.connect = function (options) { return __awaiter(_this, void 0, void 0, function () {
            var error, error, error, error, completeOptions, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.debug({ type: 'breadcrumb', message: 'connect', data: { polling: options.polling } });
                        if (this.didConnect) {
                            error = new Error('Reconnecting using the same client after it connected once is not allowed');
                            this.debug({ type: 'breadcrumb', message: 'error', data: error.message });
                            throw error;
                        }
                        if (this.connectionState !== ConnectionState.DISCONNECTED) {
                            error = new Error('Client must be disconnected to connect');
                            this.debug({ type: 'breadcrumb', message: 'error', data: error.message });
                            throw error;
                        }
                        if (!options.token) {
                            error = new Error('You must provide a token');
                            this.debug({ type: 'breadcrumb', message: 'error', data: error.message });
                            throw error;
                        }
                        if (this.ws && (this.ws.readyState === 0 || this.ws.readyState === 1)) {
                            error = new Error('Client already connected to an active websocket connection');
                            this.debug({ type: 'breadcrumb', message: 'error', data: error.message });
                            throw error;
                        }
                        completeOptions = {
                            token: options.token,
                            urlOptions: options.urlOptions || { secure: false, host: 'eval.repl.it', port: '80' },
                            timeout: options.timeout || null,
                            WebSocketClass: options.polling ? EIOCompat_1.EIOCompat : getWebSocketClass(options),
                            polling: !!options.polling,
                        };
                        this.connectionState = ConnectionState.CONNECTING;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4, this.tryConnect(completeOptions)];
                    case 2:
                        _a.sent();
                        return [3, 4];
                    case 3:
                        e_1 = _a.sent();
                        this.connectionState = ConnectionState.DISCONNECTED;
                        this.debug({ type: 'breadcrumb', message: 'error', data: e_1.message });
                        throw e_1;
                    case 4:
                        this.connectionState = ConnectionState.CONNECTED;
                        this.didConnect = true;
                        return [2];
                }
            });
        }); };
        _this.openChannel = function (_a) {
            var name = _a.name, service = _a.service, action = _a.action;
            var ac = action;
            if (!ac) {
                ac = name == null ? protocol_1.api.OpenChannel.Action.CREATE : protocol_1.api.OpenChannel.Action.ATTACH_OR_CREATE;
            }
            _this.debug({
                type: 'breadcrumb',
                message: 'openChannel',
                data: {
                    name: name,
                    service: service,
                    action: ac,
                },
            });
            var channel = new channel_1.Channel();
            var ref = Number(Math.random()
                .toString()
                .split('.')[1]).toString(36);
            _this.getChannel(0).send({
                ref: ref,
                openChan: {
                    name: name,
                    service: service,
                    action: ac,
                },
            });
            var onResponse = function (cmd) {
                if (ref !== cmd.ref) {
                    return;
                }
                if (cmd.openChanRes == null) {
                    throw new Error('Expected openChanRes on command');
                }
                _this.handleOpenChanRes(channel, cmd.openChanRes);
                _this.getChannel(0).off('command', onResponse);
            };
            _this.getChannel(0).on('command', onResponse);
            return channel;
        };
        _this.close = function () { return _this.onClose({ expected: true }); };
        _this.send = function (cmd) {
            _this.debug({ type: 'log', log: { direction: 'out', cmd: cmd } });
            var cmdBuf = protocol_1.api.Command.encode(cmd).finish();
            var buffer = cmdBuf.buffer.slice(cmdBuf.byteOffset, cmdBuf.byteOffset + cmdBuf.length);
            if (_this.ws == null) {
                throw new Error('Calling send on a closed client');
            }
            _this.ws.send(buffer);
        };
        _this.onSocketMessage = function (_a) {
            var data = _a.data;
            var d = new Uint8Array(data);
            var cmd = protocol_1.api.Command.decode(d);
            _this.debug({ type: 'log', log: { direction: 'in', cmd: cmd } });
            _this.getChannel(cmd.channel).onCommand(cmd);
            switch (cmd.body) {
                case 'containerState':
                    if (cmd.containerState == null || cmd.containerState.state == null) {
                        var err = new Error('Expected container state to have state, got null or undefined');
                        if (_this.deferredReady) {
                            _this.deferredReady.reject(err);
                            return;
                        }
                        _this.debug({ type: 'breadcrumb', message: 'error', data: err.message });
                        throw err;
                    }
                    _this.debug({
                        type: 'breadcrumb',
                        message: 'containerState',
                        data: _this.containerState,
                    });
                    _this.containerState = cmd.containerState.state;
                    if (_this.containerState === protocol_1.api.ContainerState.State.READY) {
                        if (_this.deferredReady) {
                            _this.deferredReady.resolve();
                            _this.deferredReady = null;
                        }
                        if (_this.getChannel(0).isOpen === false) {
                            _this.getChannel(0).onOpen(0, protocol_1.api.OpenChannelRes.State.CREATED, _this.send);
                        }
                    }
                    if (_this.containerState === protocol_1.api.ContainerState.State.SLEEP) {
                        _this.onClose({ expected: false });
                    }
                    break;
                case 'closeChanRes':
                    if (cmd.closeChanRes == null) {
                        throw new Error('Expected closeChanRes');
                    }
                    _this.handleCloseChannel(cmd.closeChanRes);
                    break;
                default:
            }
        };
        _this.handleOpenChanRes = function (channel, _a) {
            var id = _a.id, state = _a.state, error = _a.error;
            _this.debug({ type: 'breadcrumb', message: 'openChanres' });
            if (state === protocol_1.api.OpenChannelRes.State.ERROR) {
                _this.debug({ type: 'breadcrumb', message: 'error', data: error });
                channel.onOpenError({ error: error });
                return;
            }
            if (id == null || state == null) {
                throw new Error('Expected state and channel id');
            }
            _this.channels[id] = channel;
            channel.onOpen(id, state, _this.send);
        };
        _this.handleCloseChannel = function (_a) {
            var id = _a.id, status = _a.status;
            _this.debug({
                type: 'breadcrumb',
                message: 'handleCloseChannel',
                data: { id: id, status: status },
            });
            if (id == null) {
                throw new Error('Closing channel with no id?');
            }
            _this.channels[id].onClose({ id: id, status: status });
            delete _this.channels[id];
        };
        _this.onClose = function (_a) {
            var closeEvent = _a.closeEvent, expected = _a.expected;
            _this.connectionState = ConnectionState.DISCONNECTED;
            _this.containerState = null;
            _this.debug({
                type: 'breadcrumb',
                message: 'close',
                data: {
                    expected: expected,
                    closeReason: closeEvent ? closeEvent.reason : undefined,
                },
            });
            if (_this.ws) {
                _this.ws.onmessage = null;
                _this.ws.onclose = null;
                if (_this.ws.readyState === 0 || _this.ws.readyState === 1) {
                    _this.debug({
                        type: 'breadcrumb',
                        message: 'wsclose',
                        data: {
                            expected: expected,
                            closeReason: closeEvent ? closeEvent.reason : undefined,
                        },
                    });
                    _this.ws.close();
                }
                _this.ws = null;
            }
            if (_this.didConnect) {
                Object.keys(_this.channels).forEach(function (id) {
                    _this.handleCloseChannel({ id: Number(id) });
                });
            }
            if (_this.deferredReady) {
                _this.deferredReady.reject(new Error('Connection closed before the server was ready'));
                _this.deferredReady = null;
            }
            _this.emit('close', { closeEvent: closeEvent, expected: expected });
        };
        _this.onSocketClose = function (closeEvent) {
            if (_this.connectionState !== ConnectionState.DISCONNECTED) {
                _this.onClose({
                    closeEvent: closeEvent,
                    expected: false,
                });
            }
        };
        _this.tryConnect = function (_a) {
            var token = _a.token, urlOptions = _a.urlOptions, polling = _a.polling, timeout = _a.timeout, WebSocketClass = _a.WebSocketClass;
            return __awaiter(_this, void 0, void 0, function () {
                var connStr, ws, rej, timeoutId, res;
                var _this = this;
                return __generator(this, function (_b) {
                    this.debug({ type: 'breadcrumb', message: 'connect internal', data: { polling: polling } });
                    if (this.connectionState === ConnectionState.DISCONNECTED) {
                        throw new Error('closed while connecting');
                    }
                    this.token = token;
                    connStr = Client.getConnectionStr(token, urlOptions);
                    ws = new WebSocketClass(connStr);
                    ws.binaryType = 'arraybuffer';
                    ws.onmessage = this.onSocketMessage;
                    ws.onclose = this.onSocketClose;
                    this.ws = ws;
                    this.deferredReady = deferred_1.createDeferred();
                    rej = this.deferredReady.reject;
                    if (timeout != null) {
                        timeoutId = setTimeout(function () {
                            _this.debug({ type: 'breadcrumb', message: 'timeout' });
                            if (_this.deferredReady) {
                                rej(new Error('timeout'));
                                _this.deferredReady = null;
                            }
                            _this.close();
                        }, timeout);
                    }
                    this.deferredReady.reject = function (reason) {
                        clearTimeout(timeoutId);
                        rej(reason);
                    };
                    res = this.deferredReady.resolve;
                    this.deferredReady.resolve = function (v) {
                        _this.debug({ type: 'breadcrumb', message: 'connected!' });
                        _this.startPing();
                        clearTimeout(timeoutId);
                        res(v);
                    };
                    return [2, this.deferredReady.promise];
                });
            });
        };
        _this.startPing = function () {
            var chan0 = _this.getChannel(0);
            var pingTime = Date.now();
            var ping = function () {
                if (chan0.closed) {
                    return;
                }
                pingTime = Date.now();
                chan0.send({ ping: {} });
            };
            chan0.on('command', function (cmd) {
                if (cmd.body === 'pong') {
                    var pongTime = Date.now();
                    var latency = pongTime - pingTime;
                    _this.debug({ type: 'ping', latency: latency });
                    setTimeout(ping, 10 * 1000);
                }
            });
            ping();
        };
        _this.ws = null;
        _this.channels = {
            0: new channel_1.Channel(),
        };
        _this.deferredReady = null;
        _this.containerState = null;
        _this.token = null;
        _this.connectionState = ConnectionState.DISCONNECTED;
        _this.debug = debug;
        _this.didConnect = false;
        _this.debug({ type: 'breadcrumb', message: 'constructor' });
        return _this;
    }
    Client.getConnectionStr = function (token, urlOptions) {
        var secure = urlOptions.secure, host = urlOptions.host, port = urlOptions.port;
        return "ws" + (secure ? 's' : '') + "://" + host + ":" + port + "/wsv2/" + token;
    };
    Client.prototype.getChannel = function (id) {
        var chan = this.channels[id];
        this.debug({
            type: 'breadcrumb',
            message: 'getChannel',
            data: {
                id: id,
            },
        });
        if (!chan) {
            var error = new Error("No channel with number " + id);
            this.debug({ type: 'breadcrumb', message: 'error', data: error.message });
            throw error;
        }
        return chan;
    };
    Client.prototype.getToken = function () {
        if (!this.token) {
            return null;
        }
        return this.token;
    };
    Client.prototype.setDebugFunc = function (debugFunc) {
        this.debug = debugFunc;
    };
    return Client;
}(events_1.EventEmitter));
exports.Client = Client;
//# sourceMappingURL=client.js.map