"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var eio = require("engine.io-client");
var urllib = require("url");
function splitHref(href) {
    var parsed = urllib.parse(href);
    var protocol = parsed.protocol, slashes = parsed.slashes, auth = parsed.auth, host = parsed.host, pathname = parsed.pathname;
    var uri = urllib.format({
        protocol: protocol,
        slashes: slashes,
        auth: auth,
        host: host,
        query: { ordered: '1' },
    });
    var path = pathname != null ? pathname : '/';
    return { uri: uri, path: path };
}
exports.splitHref = splitHref;
var sequenceBytesCount = 4;
var readyStateStringToValue = new Map([
    ['opening', 0],
    ['open', 1],
    ['closing', 2],
    ['closed', 3],
]);
var EIOCompat = (function () {
    function EIOCompat(url, protocols) {
        var _this = this;
        this.CLOSED = 3;
        this.CLOSING = 2;
        this.OPEN = 1;
        this.CONNECTING = 0;
        if (protocols) {
            throw new Error('Passing protocols is not implemented');
        }
        var _a = splitHref(url), uri = _a.uri, path = _a.path;
        this.onopen = null;
        this.onclose = null;
        this.onmessage = null;
        this.onerror = null;
        this.eioSocket = eio(uri, { path: path, transports: ['polling'] });
        this.url = url;
        this.extensions = '';
        this.protocol = '';
        this.bufferedAmount = 0;
        this.binaryType = 'blob';
        this.readyState = 0;
        this.incomingSequence = 0;
        this.outOfOrderQueue = {};
        this.outgoingSequence = 0;
        this.setReadyState();
        this.eioSocket.on('open', function () {
            _this.setReadyState();
            if (_this.onopen != null) {
                var event_1 = new Event('open');
                _this.onopen.call(_this, event_1);
            }
        });
        this.eioSocket.on('close', function (reason) {
            _this.setReadyState();
            if (_this.onclose != null) {
                var event_2 = new CloseEvent('close', {
                    reason: reason,
                    code: 1001,
                    wasClean: false,
                });
                _this.onclose.call(_this, event_2);
            }
        });
        this.eioSocket.on('message', function (data) {
            _this.setReadyState();
            if (_this.onmessage == null) {
                return;
            }
            if (typeof data === 'string') {
                throw new Error('expected data to be ArrayBuffer not string');
            }
            var view = new DataView(data);
            var sequence = view.getUint32(0);
            if (_this.incomingSequence !== sequence) {
                _this.outOfOrderQueue[sequence] = data.slice(sequenceBytesCount);
                return;
            }
            _this.incomingSequence = sequence + 1;
            var message = new MessageEvent('message', {
                data: data.slice(sequenceBytesCount),
            });
            var onmessage = _this.onmessage.bind(_this);
            onmessage(message);
            var queuedSequences = Object.keys(_this.outOfOrderQueue);
            if (queuedSequences.length > 0) {
                queuedSequences.sort().forEach(function (seq) {
                    onmessage(new MessageEvent('message', {
                        data: _this.outOfOrderQueue[+seq],
                    }));
                    _this.incomingSequence = +seq + 1;
                });
                _this.outOfOrderQueue = {};
            }
        });
        this.eioSocket.on('error', function () {
            _this.setReadyState();
            if (_this.onerror != null) {
                var event_3 = new Event('error');
                _this.onerror.call(_this, event_3);
            }
        });
    }
    EIOCompat.prototype.setReadyState = function () {
        this.readyState = readyStateStringToValue.get(this.eioSocket.readyState);
    };
    EIOCompat.prototype.send = function (buffer) {
        var sequencedBuffer = new ArrayBuffer(sequenceBytesCount + buffer.byteLength);
        new Uint8Array(sequencedBuffer).set(new Uint8Array(buffer), sequenceBytesCount);
        var view = new DataView(sequencedBuffer);
        view.setUint32(0, this.outgoingSequence);
        this.outgoingSequence += 1;
        this.eioSocket.send(sequencedBuffer);
        this.setReadyState();
    };
    EIOCompat.prototype.close = function () {
        this.onmessage = null;
        this.eioSocket.close();
        this.setReadyState();
    };
    EIOCompat.prototype.addEventListener = function () {
        throw new Error('Not Implemented, please use onmessage, onopen, onerror, or onclose');
    };
    EIOCompat.prototype.removeEventListener = function () {
        throw new Error('Not Implemented');
    };
    EIOCompat.prototype.dispatchEvent = function () {
        throw new Error('Not Implemented');
    };
    return EIOCompat;
}());
exports.EIOCompat = EIOCompat;
//# sourceMappingURL=EIOCompat.js.map